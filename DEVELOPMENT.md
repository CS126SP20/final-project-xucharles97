# Development

---

- **4/21/2020** Managed to successfully compile CMake
    - Encountered and resolved error regarding CINDER_PATH
        - Somehow the CINDER_PATH variable in all the CMake files were changed
        - It took me a long time to troubleshoot because the error messages were correlated to other lines of code (not the variable declaration)
            - Due to my unfamiliarity with CMake, I didn't realize the error was with the variable declaration itself and not with the lines in the error messages
    - Tried SFML and Godot, but couldn't figure out a way to integrate either of them into the exisitng final project
        - Decided to try and switch to Box2D, will try to integrate it tomorrow
        
    

- **4/23/2020** Managed to successfully import Box2D
    - Encountered permissions error (error code 13)
        - Resolved by editing the executable in the configurations
    - Had to reinstall Cinder because CLion wasn't recognizing Box2D cloned from git
        - When I tried to include Box2D in CMake/the header in my code, CLion didn't recognize it
        - Not sure why exactly reinstalling Cinder worked, I just saw someone else do it on Piazza to address the same issue so I tried it out 


- **4/24/2020** Successfully added base objects from Box2D
    - Added and defined a vector object for gravity and used it to initiate a world object
        - Printed out one of the vector values to verify that everything worked
        
- **4/28/2020** Worked on figuring out how to visually display a Box2D World object in Cinder
    - The official Box2D tutorials and documentation online only talked about how to create things with the default Box2D library
        - Had to find a way to integrate it with Cinder
        - Added ConversionUtils to convert from the Box2D world to the Cinder display
        - Added GameWorld class to store all the parts of a specific scene/level in the game
            - Makes it easier to add more levels later on, allowing for more scalability
            
 - **4/29/2020**
    - Fleshed out ConversionUtils and GameWorld classes
        - Added various scaling helper functions to ConversionUtils to (hopefully) be able to scale the GameWorld properly
    - Changed how I planned on storing the body data in GameWorld class a few times
        - Initially it was going to be a vector of b2BodyDefs
        - Changed to a vector of b2Body* instead (since that's what the actualy fixtures are tied to)
        - Decided to create a GameBody class instead to store all my data
            - This way I can also keep track of the exact size, color, etc of all the blocks
            - Realized this would be necessary when I started to fill in code for the DrawWorld function in my_app
    - Added the GameBody class to store all information related to a given body, will flesh out later
    
 - **5/01/2020**
    - Fleshed out GameBody class
        - Added all the variables (b2Body*, color, width/height, etc)
        - Created the standard constructor
            - Takes in a b2Body* (generated by a GameWorld), and position/dimension values
            - Sets the body as a rectangle by default
            - Color is green by default
        - Added a draw() function
            - Creates a vec2 pos vector to represent the coordinates on-screen
            - Draws a rect based on the vec2
            - Will probably update the vec2 later so that it scales to a dynamic camera
        - Updated the vector in GameWorld to use GameBody instead of b2Body*
    - Figured out why I was having so much trouble displaying the Box2D objects in Cinder
        - I closed CLion a few days ago (computer was overheating), and when I reopened it the configurations were wrong
            - Didn't notice at first, so I spent a long time trying different ways to draw all the objects
            - Changed the configurations and was able to draw it now
            
- **5/03/2020**
    - Added definitions to various methods in GameBody class
        - Mainly just the getters methods I didn't fill in before, nothing too significant here
    - Tried to add a DynamicBody for the player into the World
        - Initially tried to add the player as its own b2Body within GameWorld
            - I know this isn't the best design, I just did this for now to get the basics going
                - I'll create a PlayerBody class later
            - I was able to draw the a red rectangle to represent the Player when I used the b2BodyDef parameters in the Rectf
                - However, a b2BodyDef's position doesn't update according to forces like gravity
            - Switched to using the b2Body* instead
                - Was able to change it's position in the Box2D engine based on gravity (printed the coordinates to check)
                - However, the player box was no longer being drawn on screen
                - Not sure why this was. When I printed out the coordinates, they were clearly still within the boundaries of the screen
                    - Even added some other static blocks to the top corners to check
        - Wasn't able to get that to work, so I decided to try and add a GameBody player variable to the GameWorld class
            - Updated the GameBody constructor to check the b2Body* input type
            - Wasn't able to run the program past the first iteration before it crashed, not sure why
                - Will do further debugging tomorrow
                
- **5/04/2020** Managed to animate the player body properly in cinder
    - Started off trying to debug what I started yesterday
        - Wasn't able to figure out why exactly it the GameBody approach causing the program to crash
            - However, I do believe it had something to do with the way the memory was being handled, since there were so many versions of the player b2Body* floating around
        - With how complicated the GameBody approach got, I eventually decided to go back to my original method of trying to draw the player in the GameWorld::draw() function
            - Since I was having so much trouble understanding and debugging the GameBody approach, I felt that it probably wasn't really good design/memory handling, which is why I decided to switch
            - I understood this method much better, and by all intents and purposes the world was being simulated properly (based on the print statements I made)
                - However, for some reason, the updated coordinates of the player object in Box2D weren't getting passed to the cinder draw() function (the player box just wouldn't show up at all)
    - Eventually decided to "soft reset" everything with a back-to-basics sort of approach
        - Reverted the branch back to what I had yesterday, deleted everything related to the player from GameWorld
            - Drew a simple static object in cinder to start (and to use as a reference for coordinates)
            - Realized that the issue was most likely related to where the player object was getting drawn
                - Had to be drawn in the main cinder draw() function instead of just some function in GameWorld, so I instead made getters and setters for the player variable in GameWorld
                    - This way, I could still simulate the player in the world, but I would also be able to access the player data from my_app in order to draw the screen
        - Got rid of all the GameWorld player variables except for b2Body*, as all the other information should be stored in the b2Body* anyways
   
- **5/05/2020**
    - Gave the player left/right movement functionality
        - Added a PlayerBody class
            - PlayerBody contains the same dynamic b2Body* used in GameWorld, but stores other helpful data, like the number of jumps, as well as helper functions to move the player
            - This allows for easily adjustable player parameters, which will be especially useful once I start making levels
        - Added a PlayerBody to the GameWorld as an instance variable but kept the original b2Body* player so that the player would still be a part of the physics simulation
        - Created an enum for left/right/stop in PlayerBody.h to tell the horizontal velocity of the player
        - Added booleans to my_app in order to tell which of the directional keys were down
        - Initially used a switch statement in keyDown() to tell which direction to go on (like in Snake)
            - Ran into an issue where it couldn't keep track of multiple inputs at once
            - If I tried running it without any breaks then it would run count multiple directions
                - This manifested as a bug where, regardless of input direction, the block would always go right
                    - This is because the right key always has highest priority when processing the directional inputs in PlayerBody
            - Eventually added break statements, but the player would then only stop/change direction if another key was pressed
                - Realized I had to add a keyUp() override so that when a key was lifted, then that key's respective boolean was set to false
    - As I was moving the player around, I realized there was an error in the way the Box2D objects were being displayed on screen
        - I was running into a bunch of invisible walls which I soon realized were where the static bodies were supposed to be
        - Played around with the way I was drawing my objects for a bit, then I realized I had completely misunderstood how I was supposed to use Box2D
            - The parameters I was using for Box2D were way too big for Box2D
                - I was doing 1 pixel/Box2D meter, when in reality, Box2D can't handle numbers that big
        - Decided to rewrite and reimplement my ConversionUtils class now that I have a better understanding of Box2D
            - Originally added it because I saw someone else do something similar on a guide online, but I never understood why since at that point I was still trying to grasp how the whole engine worked
        - Reintegrated ConversionUtils to properly scale the Gamebody objects between Box2D and the screen
 
- **5/05/2020**            
    - Reintegrated ConversionUtils to properly scale PlayerBody objects between Box2D and the screen
        - The invisible wall glitch has been fixed
    - Now all GameBody objects (including PlayerBody) take in and store their respective dimensions and positions as they appear on the Box2D coordinate system
        - GameWorld automatically takes in the screen coordinates and converts them into Box2D coordinates in the createBody() and setPlayer() objects
        - The width/height are stored as their respective half values, as that is how they are represented in Box2D
    - Added ability for player to jump by applying an upwards impulse on the body
        - Added a sensor on the bottom of the player and added a ContactListener class to detect collisions with the ground
            - Spent a lot of time trying to figure out how to set up ContactListener properly
            - Eventually realized I was overcomplicating it and only needed to set the footSensorData to the PlayerBody object
    - First attempt at integrating EndContact didn't work
        - For some reason footSensor->SetUserData(this) stored the correct information all the way up until the ContactListener was actually called
            - Couldn't figure out where it was being lost (when I ran the debugger it happened somewhere in the Box2D methods), so I reverted the branch
        - Second attempt didn't work either, decided to do it without the ContactListener
    - Eventually got the jumping mechanics to work by using the player's velocity to determine if they were falling
        - If their acceleration was downwards and but y velocity is 0, then they must be on the ground
    - Added the LevelMaker class
        - Operates as a pseudo-interface
            - Each level in the game will implement the loadLevel() virtual function to create its own GameWorld
            - Each LevelMaker object will be connected to the next level via a LinkedList
        - Added some util/convenience methods to GameBody and GameWorld to allow for further compatability with LevelMaker
            - GameBody now has a function to set its color
            - GameWorld now has:
                - More overloaded CreateBody functions, including one to set the color of the GameBody
                - An endpoint that the player must reach
                - And a bottom boundary for bottomless pits
    - After integrating the first LevelMaker in my_app, the engine I had made stopped working for some reason
        - The collision mechanics became non-existent. Whenever the player touched a block, they would simply fall through and the game would crash.
        - Wasn't able to figure out why before the Wednesday night deadline.             
        
           
        
  
        
    